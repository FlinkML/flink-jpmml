/*
 * Copyright (C) 2017  Radicalbit
 *
 * This file is part of flink-JPMML
 *
 * flink-JPMML is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * flink-JPMML is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with flink-JPMML.  If not, see <http://www.gnu.org/licenses/>.
 */

package io.radicalbit.examples.sources

import io.radicalbit.flink.pmml.scala.models.control.ServingMessage
import org.apache.flink.streaming.api.scala._

object ControlSource {

  sealed trait Mode

  case object Loop extends Mode
  case object Finite extends Mode
  case object Random extends Mode

  val procedures = Seq(Loop, Finite, Random)

  /**
    * Generation control stream method: it has three main generation logic (called _policies_):
    * - INFINITE:
    *   - Loop Generation : The events are generating by infinitely looping over the paths' sequence
    *   - Random Generation : The events are randomly generated by picking from the paths' sequence
    * - FINITE:
    *   - Finite Generation : The events are generating 1-to-1 with the paths' sequence
    * @param env The Stream execution environment
    * @param mode Generation policy
    * @param mappingIdPath The list of the id. and path of the models that users want to employ into generation
    * @param maxInterval Max Interval between controls' generation
    * @return
    */
  def generateStream(env: StreamExecutionEnvironment,
                     mode: Mode,
                     mappingIdPath: Map[String, String],
                     maxInterval: Long): DataStream[ServingMessage] =
    mode match {
      case Loop => env.addSource(new InfiniteSource(mappingIdPath, Loop, maxInterval))
      case Random => env.addSource(new InfiniteSource(mappingIdPath, Random, maxInterval))
      case Finite => env.addSource(new FiniteSource(mappingIdPath, maxInterval))
      case _ => env.addSource(new InfiniteSource(mappingIdPath, Random, maxInterval))
    }

}
